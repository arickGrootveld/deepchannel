import numpy as np

### Main functionality of this file, if called will format data for TCN
if __name__ == "__main__":
    import hdf5storage as h5
    import argparse
    import time

    start = time.time()

    parser = argparse.ArgumentParser(description='Format Man Targ Data Generated by maneuvering script')
    
    parser.add_argument('--testData', action='store_true',
                        help='whether the data specified should be'
                        'made into test data (default: False)')

    parser.add_argument('--dataFile', type=str, default='data/manTargOut.mat',
                        help='location of file to load data from'
                        '(default: data/manTargOut.mat)')

    parser.add_argument('--saveFile', type=str, default='None',
                        help='location to save the data, if nothing specified'
                        'will save to the highest numbered ManTarg file in data'
                        '(default: None)')

    # Get arguments from the command line parser
    args = parser.parse_args()
    testMode = args.testData
    fileLoc = args.dataFile
    saveLoc = args.saveFile

    # Pre-defining the dictionary that will contain the data
    saveData = dict()

    ## Getting data out of file 
    print('data loaded from: ' + fileLoc)
    loadData = h5.loadmat(fileLoc)

    obsStuff = loadData['XX']
    sysStuff = loadData['YY']

    numSamples = obsStuff.shape[0]
    seqLen = obsStuff.shape[1]

    ## Make train or eval data
    if not testMode:
        

        # Preallocating the tensors for the saved data
        observedStates = np.zeros((2, seqLen, numSamples))
        finalStateValues = np.zeros((4, numSamples))

        # Dummy variable for holding systemStateData that we don't care about
        systemStates = np.ones((2, seqLen + 1, numSamples))

        ## TODO: Add system states portion of data

        # Reformatting the data to match what the TCN expects
        for i in range(0, numSamples):
            # Rearranging the system state data to have expected dimensions
            # Also this will save zeros to the locations for the estimates,
            # so cannot do estimation with this data (currently)
            finalStateValues[(1,3), i] = sysStuff[i, :]
            # Saving the observed states one at a time to get around
            # issues with broadcasting sizes
            observedStates[0, :, i] = obsStuff[i,:,0]
            observedStates[1, :, i] = obsStuff[i,:,1]

        saveData['observedStates'] = observedStates
        saveData['finalStateValues'] = finalStateValues
        saveData['systemStates'] = systemStates
        saveData['riccatiConvergences'] = np.zeros((2,2))

        
        # Saving the data to either the specified file or the default arrangement
        if saveLoc == 'None':
            from utilities import matSave
            matSave('data', 'manTargData', saveData)
        else:
            print('data saved to: ' + saveLoc)
            h5.savemat(saveLoc, saveData)

        print('worked?')

    ## TODO: Write code to formatting to test data
    ## Make test data
    else:
        batchSize = 250
        numBatches = int(np.floor(numSamples / batchSize))
        if numBatches <= 1:
            raise ValueError('The amount of data isnt large enough for this batch size')
        
        measuredStateTEST = np.zeros((1, batchSize, 2, seqLen, numBatches))
        trueStateTEST = np.zeros((1, batchSize, 4, numBatches))
        # Creating dummy variables for the LS data as we don't care about their
        # values
        lsAkfData0 = np.zeros((2, seqLen + 1, numSamples))
        lsAkfData1 = np.zeros((2, seqLen, numSamples))
        lsAkfData2 = np.zeros((4, numSamples))
        LSandKFTestData = [[lsAkfData0, lsAkfData1, lsAkfData2]]

        for i in range(0, numBatches):
            batchStart = i * batchSize
            batchEnd = i * batchSize + batchSize
            measuredStateTEST[0, :, 0, :, i] = obsStuff[batchStart:batchEnd, :, 0]
            measuredStateTEST[0, :, 1, :, i] = obsStuff[batchStart:batchEnd, :, 1]
            trueStateTEST[0, :, 1, i] = sysStuff[batchStart:batchEnd, 0]
            trueStateTEST[0, :, 3, i] = sysStuff[batchStart:batchEnd, 1]

        saveData['trueStateTEST'] = trueStateTEST
        saveData['measuredStateTEST'] = measuredStateTEST
        saveData['LSandKFTestData'] = LSandKFTestData

        testDataInfoDict = dict()
        # Saving some dummy data to the test data info to get the TCN to run
        testDataInfoDict['riccatiConvergencePred'] = 0
        testDataInfo = [testDataInfoDict]
        saveData['testDataInfo'] = testDataInfo

        # testDataToBeLoaded['measuredStateTEST'].shape = (1, 32, 2, 20, 31)
        # testDataToBeLoaded['trueStateTEST'].shape = (1, 32, 4, 31)
        # testDataToBeLoaded['LSandKFTestData'][0,0].shape = (2, 21, 1000)
        # testDataToBeLoaded['LSandKFTestData'][0,1].shape = (2, 20, 1000)
        # testDataToBeLoaded['LSandKFTestData'][0,2].shape = (4, 1000)
        # 

        if saveLoc == 'None':
            from utilities import matSave
            matSave('data', 'manTargTest', saveData)
        else:
            print('data saved to: ' + saveLoc)
            h5.savemat(saveLoc, saveData)
        
        print('test data finished')
    curTime = time.time()
    totalTimeTaken = curTime - start
    print('It took {} seconds to reformat the data'.format(totalTimeTaken))