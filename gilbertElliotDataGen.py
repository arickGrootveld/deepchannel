import numpy as np
from scipy import linalg as sciAlg

# GilEllDataGen: Function that generates a sequence of data from an AR Process who's coefficients are subject to
#                a Gilbert-Elliot model. This means that the data will be generated from two sets of AR Coefficients,
#                and it will switch between the two sets (here on called "good" and "bad" states) based on a two state
#                Markov Chain
#   Inputs: (params, seed)
#         params (tuple/list): Parameters for the data generation process
#           params[0] (tuple/list) - (p,q): A list of floats that correspond to the transition probabilities of the
#                                    Markov Chain
#               params[0][0] (float) - p: The probability of transitioning from the "good" state to the "bad" state
#                                         in the Markov Chain
#               params[0][1] (float) - q: The probability of transitioning from the "bad" state to the "good" state
#           params[1] (tuple/list) - ([F_p1, F_p2], [F_q1, F_q2]): A tuple/list of tuples that corresponds to the
#                                     AR_Coefficients of the good and bad states
#               params[1][0] (tuple/list) - [F_p1, F_p2]: AR Coefficients of the good state
#                   params[1][0][0] (float) - F_p1: First AR Coefficient of the good state
#                   params[1][0][1] (float) - F_p2: Second AR Coefficient of good state
#               params[1][1] (tuple/list) - [F_q1, F_q2]: AR Coefficients of the bad state
#                   params[1][1][0] (float) - F_q1: First AR Coefficient of bad state
#                   params[1][1][1] (float) - F_q2: Second AR Coefficient of bad state
#           params[2] (int) - sequenceLength: Length of the sequence of data to be generated
#           params[3] (tuple/list) - [Q_diag,R]: List of the covariances of the AR Process Noises
#               params[3][0] (float) - Q_diag = 0.1: The upper left number in the Q matrix that forms the covariance
#                                               matrix of the AR system noise v[k] {Default=0.1}
#               params[3][1] (float) - R = 0.1: The covariance of the AR observation noise w[k] {Default=0.1}
#           params[4] (str) - startState =  'good': A string that tells you which state the Markov Chain should
#                                                   start in, the 3 options supported at this time are 'good'
#                                                   which causes the system to start in the good state, 'bad'
#                                                   which causes the system to start in the bad state, and
#                                                   'random', which starts the system in a random state, with a 50/50
#                                                   chance of starting in either state. {Default='good'}
#       seed=-1 (int) - The seed of the RNG state that this function uses to generate random numbers. If this
#                       value is less than 1, then it will be ignored, and no seed will be set {default=-1}
#   Outputs: (sequenceData)
#       sequenceData (tuple) - A tuple that contains the data that was generated by the Gilbert Elliot AR Process
#           sequenceData[0] (complex128 np.matrix) - trueSequence: A sequence of complex numbers that form the
#                                                                  system states of a Gilbert-Elliot AR Process
#           sequenceData[1] (complex128 np.matrix) - observedSequence: A sequence of complex numbers that form the
#                                                                      observed sequence of data created by a a
#                                                                      Gilbert-Elliot AR Process
#           sequenceData[2] (np.matrix) - ricattiConvergences: The matrix containing the Ricatti Convergences of the two
#                                                              sets of AR Coefficients, organized with the 1st dimension
#                                                              consisting of the MSE convergence of the prediction and
#                                                              estimate of the good Markov State, and the 2nd dimension
#                                                              of the MSE convergence of the prediction and estimate of
#                                                              the bad Markov State. The following visual provides
#                                                              further documentation:
#                                                              [[ goodStatePredictionMSE, goodStateEstimateMSE ],
#                                                               [ badStatePredictionMSE, badStateEstimateMSE]]


def GilEllDataGen(params, seed=-1):

    states = ['good', 'bad']
    # TODO Error checking: verify that p and q are between 1 and 0
    p,q = params[0]
    transitionArray = ((p, 1-p), (q, 1-q))

    goodCoeffs = np.array(params[1][0])
    badCoeffs = np.array(params[1][1])

    sequenceLength = params[2]

    ### Setting up the Q_diag and R parameters ###
    # If this parameter was never specified in the passed parameters set both to defaults
    if(len(params) < 4):
        Q_diag = 0.1
        R = 0.1
    # If a list or tuple with a single item was passed, then assume it was the Q_diag component and default R
    elif(len(params[3]) == 1):
        Q_diag=params[3][0]
        R = 0.1
    # if a float was passed then assume that it was the Q_diag component, and default R
    elif(type(params[3]) is float):
        Q_diag = params[3]
        R = 0.1
    # Otherwise assume that both R and Q_diag were passed, and set them appropriately
    else:
        Q_diag = params[3][0]
        R = params[3][1]

    # Setting up the starting state of the Markov Chain
    if(len(params) < 5):
        MarkovState = 'good'
    elif(params[5] == 'good'):
        MarkovState = 'good'
    elif(params[5] == 'bad'):
        MarkovState = 'bad'
    elif(params[5] == 'random'):
        startingStates = ['good', 'bad']
        startingProbabilities = [0.5, 0.5]
        MarkovState = np.random.choice(startingStates, replace=True, p=startingProbabilities)

    if (seed > 0):
        np.random.seed(seed)

    ### Setting up the AR Process Variables ###

    # Noise covariance matrix / noise mean
    Q = np.matrix([[Q_diag, 0], [0, 0]])
    QChol = np.matrix([[np.sqrt(Q_diag), 0], [0, 0]])

    # Observation covariance matrix/ noise mean
    R = np.matrix([R])

    # Matrix mapping real states into observation domain (required for Riccati Equation)
    H = np.matrix([1, 0])

    # Pre-allocating the matrix that will store the true values of the system state
    x = np.empty([1, sequenceLength+1], dtype=complex)
    # Pre-allocating the current true state to be used in the AR Process equation
    x_current = np.empty([2,1], dtype=complex)

    # Pre-allocating the matrix that will store the observed states
    z = np.empty([1, sequenceLength+1], dtype=complex)

    # Pre-allocating the current observation state matrix
    z_current = np.empty([1], dtype=complex)

    # Pre-allocating for the system noise vector
    v = np.empty([2,1], dtype=complex)

    # Pre-allocating for the observation noise vector
    w = np.empty(1, dtype=complex)


    ### Computing the Riccati Convergences of the good and bad Markov states ###
    # Setting up the matrices that will be used for the equations
    riccatiConvergences = np.empty((2,2), dtype=float)
    goodF = np.matrix([goodCoeffs, [1, 0]])
    badF = np.matrix([badCoeffs, [1,0]])
    # Computing the Riccati Convergences of the two sets of Coefficients
    riccatiPredGood = sciAlg.solve_discrete_are(np.transpose(goodF), np.transpose(H), Q, R)

    kRicConIntermediate = np.add(np.matmul(np.matmul(H, riccatiPredGood), np.transpose(H)), R)
    riccatiKalGain = np.matmul(np.matmul(riccatiPredGood, np.transpose(H)), np.linalg.inv(kRicConIntermediate))

    # Computing the Riccati Equation for the good state AR process Estimate
    riccatiEstGood = riccatiPredGood - (np.matmul(np.matmul(riccatiKalGain, H), riccatiPredGood))

    riccatiPredBad = sciAlg.solve_discrete_are(np.transpose(badF), np.transpose(H), Q, R)
    kRicConIntermediate = np.add(np.matmul(np.matmul(H, riccatiPredBad), np.transpose(H)), R)
    riccatiKalGain = np.matmul(np.matmul(riccatiPredBad, np.transpose(H)), np.linalg.inv(kRicConIntermediate))

    # Computing the Riccati Equation for the good state AR process Estimate
    riccatiEstBad = riccatiPredBad - (np.matmul(np.matmul(riccatiKalGain, H), riccatiPredBad))

    # Assigning the ricatttiConvergences matrix the correct values
    riccatiConvergences[0,0] = riccatiPredGood[0,0]
    riccatiConvergences[0,1] = riccatiEstGood[0,0]
    riccatiConvergences[1,0] = riccatiPredBad[0,0]
    riccatiConvergences[1,1] = riccatiEstBad[0,0]

    




    # Examples of setting the F matrix to be either the good or bad matrix
    # F = np.matrix([goodCoeffs, [1,0])
    # F = np.matrix([badCoeffs, [1,0])

    print('test')

if __name__ == "__main__":
    import argparse
    default_q = 0.99
    default_p = 0.99
    default_F_p = (0.5, -0.4)
    default_F_q = (1.414, -0.999698)
    default_sequence_length = 10
    default_Covariances = (0.1, 0.1)
    defaultParams = [(default_p, default_q), (default_F_p, default_F_q), default_sequence_length,
                     default_Covariances]
    GilEllDataGen(defaultParams)